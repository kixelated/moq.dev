# Architect (like a boss)

It's time to get that Staff Engineer promotion.
That's right, we're talking about distributed systems design.

I'm going to walk through a few designs for the same system with increasing complexity.
There's no right answer, just pros and cons, but I'd love to hear your favorites.
Or @me with an alternative because you're super smart and I used to eat paste in school (true story).


## Requirements 
But first, a message from our sponsor: __requirements__

We're going to build a real-time media application.
There will be N broadcasters and M viewers in a room, some performing both roles.
Think Discord or Google Meet or Zoom or _your least favorite app here_.

Additional considerations:
- Some users will have poor networks.
- Some broadcasters will want higher quality/latency (ex. screen share) 
- Some users might be geo-dispersed. ex. some in Europe and some in ~~freedom land~~ North America.
- Some customers might be willing to pay for better connectivity/quality.

Got that?
Basically just make a conferencing application.

## Design 0: Peer to Peer 
We start with both the least complicated and yet somehow most complex design: __peer-to-peer__.
That's right, boot up your favorite game from the 2000s and enter your friend's IP address manually.

The design is very simple.
Users connect directly to each other without pesky intermediate servers (unless you count routers).
There should still be _some_ central server to exchange user details, like a "lobby" service, or else discovery becomes very difficult.
Sorry, we're not going to build "Media over Blockchain" or something like BitTorrent sans trackers.

The very first problem with P2P hits us immediately: how do you connect?
In a client/client protocol, one of the two peers needs to act like a server using a public IP/port.
But this usually not an option because IPv4 addresses are expensive and IPv6 addresses are somehow still unavailable.
Instead, the internet consists of NATs that generate IP/port pairs for outgoing connections (client) but critically, reject incoming connections (server) unless configured to forward ports.

And those NATs are a headache.
WebRTC uses STUN/ICE (and the help of a middle server) to connect clients in what only can be described as a giant hack, smuggling IP/port pairs between "connections".
However even this doesnt work in all scenarios (symmetric NATs) and some peers have to resort to a TURN, literally proxying UDP/TCP traffic through a middle server.

But NATs are not the deal-breaker.
That award is reserved for _multiple participants_.

You see, if Alice is on a peer-to-peer call with Bob, then Alice needs to send their audio/video to Bob only.
Thats like 3Mb/s at least for good quality video.
But if Candy, Dandy, Eric, Fritz, Geof, Harry, Iguana, Joel, Katrina, Luke, Mochael, Nigel, üçä, Paul, Q, Raul, Steve, Tavana, Uguana, Video, Windy, Xylan, Yennifer, and Zee all join the call, then now Alice needs to send N copies of their media.
There's no way to share*; we need 78Mb/s of upload capacity now to make sure everyone gets the video.
Your home Internet might be able to support that, but what about your cell phone?

We need a different architecture.

## Design -1: Multicast
"Well of course, you daft blog author, that's why you use multicast!"

It's true, multicast is the solution. 
Instead of sending N unicast packets, you could send 1 multicast packet.
The participants would all join a multicast group and then the routers will figure it out.

Unfortunately, multicast doesn't actually work in practice.
The main problem is that you're entirely reliant on ISPs to work together and build an optimal fanout architecture.
There's limited support for multicast outside of datacenter environments that use the same brand of routers.
I'm no expert on the subject, but those experts have tried.

But I am an expert on congestion control, something that multicast doesn't really support.
You see, if you're downloading live media at 6Mb/s and your Internet suddenly has issues, the unicast solution is to lower the send rate and only transmit important data (ex. audio).
But multicast is a firehose that can't be turned off by the sender.
The only option is to have a router drop (random*) packets turning your live stream into swiss cheese.

So we're using unicast.
But, we're using _the ideas behind multicast_.

The broadcaster MUST send only one copy of the media.
Instead of the network layer (L2) performing fanout, we use the application layer (L7) instead.
That's ultimately the premise behind CDNs: more expressive routing and caching can be performed at higher layers.
But those are spoilers; keep reading.

## Design 1: Hub and Spoke
We're already at the most common architecture as far as I can tell (ex. Discord uses it).
From now on, there will be pros and cons for each design.

But first, ask yourself: "How do you determine which user connects to which server?"

I've got an answer for you: have everyone connect to the same server.

This is by far the simplest (and cheapest) architecture.
There are unfortunately two problems:

1. The maximum channel size is limited by the server size.
2. Users far away from the server will have a degraded experience.

When you hear the phrase "WebRTC doesn't scale", this is the architecture being referenced.
A single host has limits in terms of throughput and quality.
Our only option is to scale vertically, while other designs can scale horizontally.

But like I said, it is the cheapest and simplest option which is why I think it's a good fit for an application like Discord.

But _who_ decides which server to use?
Ideally the server is the net closest to all users, but what if users trickle in one at a time?
There's no right answer, only convoluted business logic, but usually it's based on the *host*.
**Fun tip**: Next time you have a meeting, make sure the lone Euro member doesn't create the meeting.

## Design 2: Point to Point 
So you're serious about improving the user experience and have spare ~~cash~~ servers.
Good?

It's time to copy a HTTP CDN and put edge servers right next to each user.
The unspoken rule of the internet: it sucks.

We want our media packets to spend as little time as possible on the public internet and as much time on our private intranet.
We then have the ability to prioritize/reserve traffic instead of fighting with the commoners using transit.
It also gives us the ability to **deduplicate**, serving the same content to multiple users kinda like multicast.
That's why Google even has a CDN edge on a cruise ship.

The other benefit of point-to-point is more subtle: it prevents __tromboning__.
For example, let's say someone from Boston is trying to call someone from the UK a ~~lolly gagger~~ (TODO make sure that properly censors the bad word).

- If we're using a single SFU in us-west, then the traffic first heads west and then back east.
- If we're using multiple SFUs, then the traffic more closely follows the shortest path.

This tromboning is rare in practice as most traffic is regional, but shush I'm trying to over-engineer the system.
We don't want to send traffic back and forth for no reason because it increases latency and reduces capacity.

So yeah, we have every user connect to the closet server via anycast or geo-DNS.
There's some database or gossip protocol used to discover the "origin" server for each user.
When the server needs to route traffic to a user, it routes it to the origin instead.

But the end result looks like a tangled mess.
Or because it 'twis the season, the end result looks more like my üéÑ lights after they magically knotted themselves in the attic (a miracle).
This is no good, because if every edge can connect to any other edge, there can be a lot of duplicated traffic on each link.

## Design 3: A Tree
The internet certainly behaves like a net.
There are many forks and traffic needs to figure out if it should go right or left.

We need to avoid our media going both left and right because it's a waste of our limited network capacity.
But we need to avoid multiple copies too.

For example, let's say an edge in the UK wants to fetch content from an origin in San Francisco
It could fetch from a server in Ireland, then New York, then Chicago, then Utah, then Frisco (nobody calls it that).
If other servers take a similar route, intersecting at some point, then we can combine multiple fetches into one.

It was called a tree at Twitch but it's really more like a river with many tributaries.
Each layer in the tree compounds, reducing hundreds of thousands of edge requests into a handful of origin requests.

But computing this tree is not easy.
It was literally created by hand at Twitch and updated every time there was outage of some sort.
The process has since been automated as some smart engineers earned their paychecks, only to be scrapped as Twitch embraced the mothership (AMZN).





## Design 4: Constraints 
