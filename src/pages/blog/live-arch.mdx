# Architect (like a boss)

It's time to get that Staff Engineer promotion.
That's right, we're talking about distributed systems design.

I'm going to walk through a few designs for the same system with increasing complexity.
There's no right answer, just pros and cons, but I'd love to hear your favorites.
Or @me with an alternative because you're super smart and I used to eat paste in school (true story).


## Requirements 
But first, a message from our sponsor: __requirements__

We're going to build a real-time media application.
There will be N broadcasters and M viewers in a room, some performing both roles.
Think Discord or Google Meet or Zoom or _your least favorite app here_.

Additional considerations:
- Some users will have poor networks.
- Some broadcasters will want higher quality/latency (ex. screen share) 
- Some users might be geo-dispersed. ex. some in Europe and some in ~~freedom land~~ North America.
- Some customers might be willing to pay for better connectivity/quality.

Got that?
Basically just make a conferencing application.

## Design 0: Peer to Peer 
We start with both the least complicated and yet somehow most complex design: __peer-to-peer__.
That's right, boot up your favorite game from the 2000s and enter your friend's IP address manually.

The design is very simple.
Users connect directly to each other without pesky intermediate servers (unless you count routers).
There should still be _some_ central server to exchange user details, like a "lobby" service, or else discovery becomes very difficult.
Sorry, we're not going to build "Media over Blockchain" or something like BitTorrent sans trackers.

The very first problem with P2P hits us immediately: how do you connect?
In a client/client protocol, one of the two peers needs to act like a server using a public IP/port.
But this usually not an option because IPv4 addresses are expensive and IPv6 addresses are somehow still unavailable.
Instead, the internet consists of NATs that generate IP/port pairs for outgoing connections (client) but critically, reject incoming connections (server) unless configured to forward ports.

And those NATs are a headache.
WebRTC uses STUN/ICE (and the help of a middle server) to connect clients in what only can be described as a giant hack, smuggling IP/port pairs between "connections".
However even this doesnt work in all scenarios (symmetric NATs) and some peers have to resort to a TURN, literally proxying UDP/TCP traffic through a middle server.

But NATs are not the deal-breaker.
That award is reserved for _multiple participants_.

You see, if Alice is on a peer-to-peer call with Bob, then Alice needs to send their audio/video to Bob only.
Thats like 3Mb/s at least for good quality video.
But if Candy, Dandy, Eric, Fritz, Geof, Harry, Iguana, Joel, Katrina, Luke, Mochael, Nigel, üçä, Paul, Q, Raul, Steve, Tavana, Uguana, Video, Windy, Xylan, Yennifer, and Zee all join the call, then now Alice needs to send N copies of their media.
There's no way to share*; we need 78Mb/s of upload capacity now to make sure everyone gets the video.
Your home Internet might be able to support that, but what about your cell phone?

We need a different architecture.

## Design -1: Multicast
"Well of course, you daft blog author, that's why you use multicast!"

It's true, multicast is the solution. 
Instead of sending N unicast packets, you could send 1 multicast packet.
The participants would all join a multicast group and then the routers will figure it out.

Unfortunately, multicast doesn't actually work in practice.
The main problem is that you're entirely reliant on ISPs to work together and build an optimal fanout architecture.
There's limited support for multicast outside of datacenter environments that use the same brand of routers.
I'm no expert on the subject, but those experts have tried.

But I am an expert on congestion control, something that multicast doesn't really support.
You see, if you're downloading live media at 6Mb/s and your Internet suddenly has issues, the unicast solution is to lower the send rate and only transmit important data (ex. audio).
But multicast is a firehose that can't be turned off by the sender.
The only option is to have a router drop (random*) packets turning your live stream into swiss cheese.

So we're using unicast.
But, we're using _the ideas behind multicast_.

The broadcaster MUST send only one copy of the media.
Instead of the network layer (L2) performing fanout, we use the application layer (L7) instead.
That's ultimately the premise behind CDNs: more expressive routing and caching can be performed at higher layers.
But those are spoilers; keep reading.

## Design 1: Hub and Spoke
We're already at the most common architecture as far as I can tell (ex. Discord uses it).
From now on, there will be pros and cons for each design.

But first, ask yourself: "How do you determine which user connects to which server?"

I've got an answer for you: have everyone connect to the same server.

This is by far the simplest (and cheapest) architecture.
There are unfortunately two problems:

1. The maximum channel size is limited by the server size.
2. Users far away from the server will have a degraded experience.

When you hear the phrase "WebRTC doesn't scale", this is the architecture being referenced.
A single host has limits in terms of throughput and quality.
Our only option is to scale vertically, while other designs can scale horizontally.

But like I said, it is the cheapest and simplest option which is why I think it's a good fit for an application like Discord.

But _who_ decides which server to use?
Ideally the server is the net closest to all users, but what if users trickle in one at a time?
There's no right answer, only convoluted business logic, but usually it's based on the *host*.
**Fun tip**: Next time you have a meeting, make sure the lone Euro member doesn't create the meeting.

## Design 2: Point to Point 
So you're serious about improving the user experience and have spare ~~cash~~ servers.
Good?

It's time to copy a HTTP CDN and put edge servers right next to each user.
The unspoken rule of the internet: it sucks.

We want our media packets to spend as little time as possible on the public internet and as much time on our private intranet.
We then have the ability to prioritize/reserve traffic instead of fighting with the commoners using transit.
It also gives us the ability to **deduplicate**, serving the same content to multiple users kinda like multicast.
That's why Google even has a CDN edge on a cruise ship.

The other benefit of point-to-point is more subtle: it prevents __tromboning__.
For example, let's say someone from Boston is trying to call someone from the UK a ~~lolly gagger~~ (TODO make sure that properly censors the bad word).

- If we're using a single SFU in us-west, then the traffic first heads west and then back east.
- If we're using multiple SFUs, then the traffic more closely follows the shortest path.

This tromboning is rare in practice as most traffic is regional, but shush I'm trying to over-engineer the system.
We don't want to send traffic back and forth for no reason because it increases latency and reduces capacity.

So yeah, we have every user connect to the closet server via anycast or geo-DNS.
There's some database or gossip protocol used to discover the "origin" server for each user.
When the server needs to route traffic to a user, it routes it to the origin instead.

But the end result looks like a tangled mess.
Or because it 'twis the season, the end result looks more like my üéÑ lights after they magically knotted themselves in the attic (a miracle).
This is no good, because if every edge can connect to any other edge, there can be a lot of duplicated traffic on each link.

## Design 3: A Tree
The internet certainly behaves like a net.
There are many forks and traffic needs to figure out if it should go right or left.

We need to avoid our media going both left and right because it's a waste of our limited network capacity.
But we need to avoid multiple copies too.

For example, let's say an edge in the UK wants to fetch content from an origin in San Francisco
It could fetch from a server in Ireland, then New York, then Chicago, then Utah, then Frisco (nobody calls it that).
If other servers take a similar route, intersecting at some point, then we can combine multiple fetches into one.

It was called a tree at Twitch but it's really more like a river with many tributaries.
Each layer in the tree compounds, reducing hundreds of thousands of edge requests into a handful of origin requests.

But computing this tree is not easy.
Ar Twitch we literally updated it by hand every time there was outage or some sort of change to the network topology.
The process has since been automated as some smart engineers earned their paychecks... only to be scrapped as Twitch was absorbed into the mothership.
But that's a tale for another time...

So yeah, we're doing some application-based routing to try and maximize the cache-hit ratio.
This means less duplicate media flowing over the backbone which means less compute and network capacity needed, which means less money burned on the cloud.
It's just getting increasingly difficult to design as users can join from any edge and leave at any time.

## Design 4: Coalesce
The key word in that last sentence is _any_.
If a user can connect to _any_ edge, then we've already started at a disadvantage.

For example, let's say there's 3 Australian viewers connecting to our service and we have 6 servers in our Sydney datacenter.
If each user connects via anycast or round-robin DNS to the "closest" edge, there's actually some randomization involved to break ties.
Our servers within the Sydney data center have equal latency so our users will be assigned randomly.
This works, but it's not the cheapest.

You see, we want all of those users to connect to the same host so we can serve them from a single cache.
If they're connected to different edges within the same datacenter, then we need to transfer the media between those hosts eating up more compute and network resources.
Every host within the datacenter provides an equal user experience (provided they aren't full) so coalescing users to the same host is pure cost savings.

We need to designate at least one server per datacenter as the "owner" of each meeting.
But there's a gotcha, as now we can cause lopsided load as some meetings are larger than others.
We also need the ability to spill over to additional servers for the largest events as a single server is not enough to serve the Superbowl.

There's a few ways to accomplish this.
One approach is to create a service that assigns each user to a host, but it quickly becomes a monolith as it needs the state of the entire system.
Another approach is to rely on hashing, returning a stateless assignment based on the meeting name with some mechanism to avoid overloading individual hosts.

## Design 5: Optimization 
Now we're in the optimization end-game.

One key flaw in the previous designs is the word "any".
We went from a user connecting to a single host to the user connecting to _any_ host.

If we get academic for just a second, we have a connected graph.
- Every node in the graph is a user or server.
- Every edge is a possible route between servers or a user.

The number of permutations balloons out of control.
Even finding the shortest path starts becoming difficult.
But we're not trying to find the shortest path, we're also trying to find a cheap one.

There's a cost associated with every node and edge.
Some are cheap, some are shit, and some are both although there's not much correlation.
Interconnect is a world of politics filled with price gouging and anti-competitive behavior.
No specifics will be mentioned lest I get sued by a South Korean ISP, or a German one, or really any nationality.

So, we have a classic graph optimization problem where every node/edge has a cost.
But what's really cool about this problem is that _only unique traffic counts_.
The more users we serve from cache, the cheaper a node/link becomes _per user_.

What's the ramifications of this?
Well, maybe serving those 3 users from Australia out of the Syndey data center isn't worth it.
It's expensive to reserve capacity on a wire sitting on the floor of the world's largest ocean.
The Aussies are used to awful Internet, how about we send their traffic over congestion transit links instead?

Maybe if there were 20 users then the cost would average out to something more palatable.
But again, users can join/leave at any time so the "optimal" decision constantly changes.
It's no feasible to constantly _recalculating splines_ so at some point you have to rely on heuristics.

And we have plenty of crude heuristics.
Before beefing up capacity, Twitch would only allow assignments to data centers based on _global_ viewership. 
20 Aussies watching a neighborhood event?
Sorry mate, best we can do is LA.
100 Brazilian viewers and the first Australian viewer shows up?
Welcome to our Sydney data center.

I believe this optimization problem is impossible to solve at scale.
But it's also the secret sauce behind every CDN; as you scale up, more can be cached but where do you draw the line between quality/cost?

