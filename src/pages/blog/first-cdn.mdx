---
layout: "@/layouts/global.astro"
title: "Cloudflare: The First MoQ CDN"
author: kixelated
description: We have a winner! Cloudflare has released a preview of their MoQ CDN. It's not an official product yet, but progress has been made.
cover: "/blog/be-the-outlier/narwhal.png"
date: 2025-08-16
---

# Cloudflare: The First MoQ CDN
ðŸš¨ It's finally happening! ðŸš¨

Cloudflare has just announced the first Media over QUIC CDN!
It's not an official product *yet*, but now you can test MoQ on their *massive*, anycast CDN.
Try it out, and convince your boss' boss that the writing is on the wall.

## Why is this important?
I've been an [outspoken critic](./transfork) of the MoQ standardization process.
It's just really difficult to design a protocol, via a cross-company committee, before there's been any real world usage.
It's been over 3 years since I fought Amazon lawyers and published my [first MoQ draft](https://www.ietf.org/archive/id/draft-lcurley-warp-00.html).
It's going to be at least another 3 years before *parts* of MoQ become an RFC.

Cloudflare has done a fantastic thing and said:
> fuck that, let's release something

Cloudflare is only supporting a *tiny* subset of an [old draft version](https://www.ietf.org/archive/id/draft-ietf-moq-transport-07.html).
This is exactly what MoQ needs right now.
**Just build something**, not pile on more theoretical arguments in the [650+ issues](https://github.com/moq-wg/moq-transport/issues) and [500+ PRs](https://github.com/moq-wg/moq-transport/pulls) for what should be a simple pub/sub protocol.

<figure>
	<iframe width="560" height="315" src="https://www.youtube.com/embed/ZXsQAXx_ao0?si=xsAscm04CnwAer4b" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen style="margin: 0 auto;"></iframe>
	<figcaption>\> me when the message encoding is changed for the 10th time.</figcaption>
</figure>

This is nowhere near a production release.
There's a lot of missing features and a lot of bugs, especially because Cloudflare is using an old fork of my terrible code.
Nothing has been optimized and the user experience will improve over time.

But **fucking finally** we are about to start using MoQ in production.


## How to use it?
There's a public `relay.cloudflare.mediaoverquic.com` endpoint that you can ~use~ abuse.
You can connect using [my library](https://github.com/kixelated/moq), [Mike's fork](https://github.com/englishm/moq-rs), or anything that supports this limited subset of draft-07.

For example, [publish a broadcast](https://github.com/kixelated/moq/blob/main/js/hang-demo/src/publish.html#L25):
```html
<script type="module">
	import "@kixelated/hang/publish/element";
</script>

<!-- You'll need to replace `name` with something unique/random. -->
<hang-publish url="https://relay.cloudflare.mediaoverquic.com" name="unique-name-abc123" audio video controls captions>
	<!-- It's optional to provide a video element to preview the outgoing media. -->
	<video style="max-width: 100%; height: auto; border-radius: 4px; margin: 0 auto;" muted autoplay></video>
</hang-publish>
```

And then you can [watch a broadcast](https://github.com/kixelated/moq/blob/9f5f6153458c03f255877a036e36f68f742d5c85/js/hang-demo/src/index.html#L30):
```html
<script type="module">
	import "@kixelated/hang/watch/element";
</script>

<!-- Use the same name as the broadcast you published. -->
<hang-watch url="https://relay.cloudflare.mediaoverquic.com" name="unique-name-abc123" muted controls captions>
	<!-- It's optional to provide a canvas if you want audio only -->
	<canvas style="max-width: 100%; height: auto; border-radius: 4px; margin: 0 auto;"></canvas>
</hang-watch>
```

You'll even get automatic closed `captions` because I've been experimenting with AI features.
Poggers indeed.

**NOTE:** You don't have to use the Web Component API.
[hang.live](./first-app) uses the Javascript API to do more complicated stuff, like get access to individual video frames.
Everything uses reactive signals which is actually a joy to work with, but it's under-documented and still evolving.

```typescript
import { Watch } from "@kixelated/hang"

// Download a broadcast, and you're in charge of rendering it.
const watch = new Watch.Broadcast({
	enabled: true,
	url: "https://relay.cloudflare.mediaoverquic.com",
	name: "unique-name-abc123",
	video: { enabled: true },
	reload: false, // required for Cloudflare's CDN
})

// Reactive properties that you can change, like:
watch.audio.enabled.set(true);

// There are helpers to convert my custom signals, like for React:
import react from "@kixelated/signals/react"
const audioInfo = react(watch.audio.info); // a JSON blob of track information

// Or you can use Vanilla JS:
const dispose = watch.video.frame.subscribe((frame?: VideoFrame) => {
	// Do something with the VideoFrame, like draw it to a canvas.
	// ...or run a ML model on it via transformers.js
})

// Or just use the built-in renderers:
const renderer = new Watch.VideoRenderer(watch.video, { canvas })

// Don't forget to call watch.close() and dispose() when you're done.
```

And if you think Javascript is an abomination (true), then you can also use the Rust client.
*Assuming that I've added draft-07 compatibility by the time you read this.*
There's a [library to import CMAF](https://github.com/kixelated/moq/tree/main/rs/hang), [which can be piped from ffmpeg](https://github.com/kixelated/moq/blob/9f5f6153458c03f255877a036e36f68f742d5c85/rs/justfile#L103), and [crude gstreamer plugins](https://github.com/kixelated/moq/blob/9f5f6153458c03f255877a036e36f68f742d5c85/rs/justfile#L119).
So you can do more complicated media stuff without ðŸ¤® Javascript ðŸ¤®.

But I'm currently focusing on the Typescript library, despite my love for Rust, because WebSupport is a big deal.
It's the reason why WebRTC was the only option, **until now**.


## What's missing?
A lot of stuff.

Cloudflare is supporting an even smaller subset than [my already tiny subset](https://www.ietf.org/archive/id/draft-lcurley-moq-lite-01.html) of the [bloated moq-transport draft](https://www.ietf.org/archive/id/draft-ietf-moq-transport-13.html).

- **There's no authentication**. Anybody can watch a broadcast, or impersonate another broadcaster, if they know the broadcast name.
- **There's a bug with reusing broadcast names**. Another reason to give your broadcast a unique name, otherwise the origin may get confused.
- **There's no [ANNOUNCE support](https://www.ietf.org/archive/id/draft-lcurley-moq-lite-01.html#name-announce)**. The [conferencing example](https://github.com/kixelated/moq/blob/main/js/hang-demo/src/meet.html) won't work without an out-of-band discovery mechanism.
- **There's no automatic reloads**. My library uses **ANNOUNCE** to detect when a broadcast starts/stops, so you can't use `reload`.

If any of those are deal breakers for you, then you can always run your own [moq-relay](https://github.com/kixelated/moq/tree/main/rs/moq-relay) until Cloudflare fixes these issues.
There's even a [terraform module](https://github.com/kixelated/moq.dev/blob/main/infra/relay.tf) used to deploy `relay.moq.dev`, clustered across multiple regions for improved QoS.
I'm currently only running 3 nodes and not a billion like Cloudflare, but it's a start.


## What's next?
A lot of stuff.

This is a demo and show of intent, not a production rollout.
The same goes for the [hang.live](./first-app) demo.
Don't judge MoQ based on these initial offerings; we've got a **ton** of work still to do.

Other companies will start releasing their own CDN offerings too.
I know that folks from Google (GCP), Akamai, Fastly, etc are authoring [moq-transport](https://datatracker.ietf.org/doc/draft-ietf-moq-transport/) with the intent of offering a CDN service in the future.
We're all pretty fed up with WebRTC and just want something simpler that scales.

If you want use MoQ or contribute, then absolutely [join the Discord](https://discord.gg/FCYF3p99mr).
I will do whatever I can to help.
*Especially* if it means putting one more nail in the WebRTC coffin.

Written by [@kixelated](https://github.com/kixelated).
![@kixelated](/blog/avatar.png)
